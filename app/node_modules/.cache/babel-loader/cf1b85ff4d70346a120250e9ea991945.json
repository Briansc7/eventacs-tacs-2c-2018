{"ast":null,"code":"/*\n\n\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar util = require('../../utils/FR'); // Force load fr localization data from moment for the locale files to be linkded durning browserify.\n// NOTE: The function moment.defineLocale() also has a side effect that it change global locale\n//  We also need to save and restore the previous locale (see. moment.js, loadLocale)\n\n\nvar originalLocale = moment.locale();\n\nrequire('moment/locale/fr');\n\nmoment.locale(originalLocale);\nvar PATTERN = new RegExp('(\\\\W|^)' + '(?:les?|la|l\\'|du|des?)\\\\s*' + '(' + util.INTEGER_WORDS_PATTERN + '|\\\\d+)?\\\\s*' + '(prochaine?s?|derni[eè]re?s?|pass[ée]e?s?|pr[ée]c[ée]dents?|suivante?s?)?\\\\s*' + '(secondes?|min(?:ute)?s?|heures?|jours?|semaines?|mois|trimestres?|années?)\\\\s*' + '(prochaine?s?|derni[eè]re?s?|pass[ée]e?s?|pr[ée]c[ée]dents?|suivante?s?)?' + '(?=\\\\W|$)', 'i');\nvar MULTIPLIER_GROUP = 2;\nvar MODIFIER_1_GROUP = 3;\nvar RELATIVE_WORD_GROUP = 4;\nvar MODIFIER_2_GROUP = 5;\n\nexports.Parser = function FRRelativeDateFormatParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    var index = match.index + match[1].length;\n    var text = match[0];\n    text = match[0].substr(match[1].length, match[0].length - match[1].length); // Multiplier\n\n    var multiplier = match[MULTIPLIER_GROUP] === undefined ? '1' : match[MULTIPLIER_GROUP];\n\n    if (util.INTEGER_WORDS[multiplier] !== undefined) {\n      multiplier = util.INTEGER_WORDS[multiplier];\n    } else {\n      multiplier = parseInt(multiplier);\n    } // Modifier\n\n\n    var modifier = match[MODIFIER_1_GROUP] === undefined ? match[MODIFIER_2_GROUP] === undefined ? '' : match[MODIFIER_2_GROUP].toLowerCase() : match[MODIFIER_1_GROUP].toLowerCase();\n\n    if (!modifier) {\n      // At least one modifier is mandatory to match this parser\n      return;\n    }\n\n    var result = new ParsedResult({\n      index: index,\n      text: text,\n      ref: ref\n    });\n    result.tags['FRRelativeDateFormatParser'] = true;\n    var modifierFactor;\n\n    switch (true) {\n      case /prochaine?s?/.test(modifier):\n      case /suivants?/.test(modifier):\n        modifierFactor = 1;\n        break;\n\n      case /derni[eè]re?s?/.test(modifier):\n      case /pass[ée]e?s?/.test(modifier):\n      case /pr[ée]c[ée]dents?/.test(modifier):\n        modifierFactor = -1;\n        break;\n    }\n\n    var total = multiplier * modifierFactor;\n    var dateFrom = moment(ref),\n        dateTo = moment(ref);\n    dateFrom.locale('fr');\n    dateTo.locale('fr');\n    var relative = match[RELATIVE_WORD_GROUP];\n    var startOf;\n\n    switch (true) {\n      case /secondes?/.test(relative):\n        dateFrom.add(total, 's');\n        dateTo.add(modifierFactor, 's');\n        startOf = 'second';\n        break;\n\n      case /min(?:ute)?s?/.test(relative):\n        dateFrom.add(total, 'm');\n        dateTo.add(modifierFactor, 'm');\n        startOf = 'minute';\n        break;\n\n      case /heures?/.test(relative):\n        dateFrom.add(total, 'h');\n        dateTo.add(modifierFactor, 'h');\n        startOf = 'hour';\n        break;\n\n      case /jours?/.test(relative):\n        dateFrom.add(total, 'd');\n        dateTo.add(modifierFactor, 'd');\n        startOf = 'day';\n        break;\n\n      case /semaines?/.test(relative):\n        dateFrom.add(total, 'w');\n        dateTo.add(modifierFactor, 'w');\n        startOf = 'week';\n        break;\n\n      case /mois?/.test(relative):\n        dateFrom.add(total, 'M');\n        dateTo.add(modifierFactor, 'M');\n        startOf = 'month';\n        break;\n\n      case /trimestres?/.test(relative):\n        dateFrom.add(total, 'Q');\n        dateTo.add(modifierFactor, 'Q');\n        startOf = 'quarter';\n        break;\n\n      case /années?/.test(relative):\n        dateFrom.add(total, 'y');\n        dateTo.add(modifierFactor, 'y');\n        startOf = 'year';\n        break;\n    } // if we go forward, switch the start and end dates\n\n\n    if (modifierFactor > 0) {\n      var dateTmp = dateFrom;\n      dateFrom = dateTo;\n      dateTo = dateTmp;\n    } // Get start and end of dates\n\n\n    dateFrom.startOf(startOf);\n    dateTo.endOf(startOf); // Assign results\n\n    result.start.assign('year', dateFrom.year());\n    result.start.assign('month', dateFrom.month() + 1);\n    result.start.assign('day', dateFrom.date());\n    result.start.assign('minute', dateFrom.minute());\n    result.start.assign('second', dateFrom.second());\n    result.start.assign('hour', dateFrom.hour());\n    result.start.assign('millisecond', dateFrom.millisecond());\n    result.end = result.start.clone();\n    result.end.assign('year', dateTo.year());\n    result.end.assign('month', dateTo.month() + 1);\n    result.end.assign('day', dateTo.date());\n    result.end.assign('minute', dateTo.minute());\n    result.end.assign('second', dateTo.second());\n    result.end.assign('hour', dateTo.hour());\n    result.end.assign('millisecond', dateTo.millisecond());\n    return result;\n  };\n};","map":null,"metadata":{},"sourceType":"script"}