{"ast":null,"code":"/*\n\n\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar util = require('../../utils/EN');\n\nvar PATTERN = new RegExp('(\\\\W|^)' + '(?:on\\\\s*?)?' + '(?:(Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\\\s*,?\\\\s*)?' + '(([0-9]{1,2})(?:st|nd|rd|th)?|' + util.ORDINAL_WORDS_PATTERN + ')' + '(?:\\\\s*' + '(?:to|\\\\-|\\\\â€“|until|through|till|\\\\s)\\\\s*' + '(([0-9]{1,2})(?:st|nd|rd|th)?|' + util.ORDINAL_WORDS_PATTERN + ')' + ')?' + '(?:-|\\/|\\\\s*(?:of)?\\\\s*)' + '(Jan(?:uary|\\\\.)?|Feb(?:ruary|\\\\.)?|Mar(?:ch|\\\\.)?|Apr(?:il|\\\\.)?|May|Jun(?:e|\\\\.)?|Jul(?:y|\\\\.)?|Aug(?:ust|\\\\.)?|Sep(?:tember|\\\\.)?|Oct(?:ober|\\\\.)?|Nov(?:ember|\\\\.)?|Dec(?:ember|\\\\.)?)' + '(?:' + '(?:-|\\/|,?\\\\s*)' + '([0-9]{1,4}(?![^\\\\s]\\\\d))' + '(\\\\s*(?:BE|AD|BC))?' + ')?' + '(?=\\\\W|$)', 'i');\nvar WEEKDAY_GROUP = 2;\nvar DATE_GROUP = 3;\nvar DATE_NUM_GROUP = 4;\nvar DATE_TO_GROUP = 5;\nvar DATE_TO_NUM_GROUP = 6;\nvar MONTH_NAME_GROUP = 7;\nvar YEAR_GROUP = 8;\nvar YEAR_BE_GROUP = 9;\n\nexports.Parser = function ENMonthNameLittleEndianParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    var result = new ParsedResult({\n      text: match[0].substr(match[1].length, match[0].length - match[1].length),\n      index: match.index + match[1].length,\n      ref: ref\n    });\n    var month = match[MONTH_NAME_GROUP];\n    month = util.MONTH_OFFSET[month.toLowerCase()];\n    var day = match[DATE_NUM_GROUP] ? parseInt(match[DATE_NUM_GROUP]) : util.ORDINAL_WORDS[match[DATE_GROUP].trim().replace('-', ' ').toLowerCase()];\n    var year = null;\n\n    if (match[YEAR_GROUP]) {\n      year = match[YEAR_GROUP];\n      year = parseInt(year);\n\n      if (match[YEAR_BE_GROUP]) {\n        if (/BE/i.test(match[YEAR_BE_GROUP])) {\n          // Buddhist Era\n          year = year - 543;\n        } else if (/BC/i.test(match[YEAR_BE_GROUP])) {\n          // Before Christ\n          year = -year;\n        }\n      } else if (year < 10) {\n        // require single digit years to always have BC/AD\n        return null;\n      } else if (year < 100) {\n        year = year + 2000;\n      }\n    }\n\n    if (year) {\n      result.start.assign('day', day);\n      result.start.assign('month', month);\n      result.start.assign('year', year);\n    } else {\n      //Find the most appropriated year\n      var refMoment = moment(ref);\n      refMoment.month(month - 1);\n      refMoment.date(day);\n      refMoment.year(moment(ref).year());\n      var nextYear = refMoment.clone().add(1, 'y');\n      var lastYear = refMoment.clone().add(-1, 'y');\n\n      if (Math.abs(nextYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref)))) {\n        refMoment = nextYear;\n      } else if (Math.abs(lastYear.diff(moment(ref))) < Math.abs(refMoment.diff(moment(ref)))) {\n        refMoment = lastYear;\n      }\n\n      result.start.assign('day', day);\n      result.start.assign('month', month);\n      result.start.imply('year', refMoment.year());\n    } // Weekday component\n\n\n    if (match[WEEKDAY_GROUP]) {\n      var weekday = match[WEEKDAY_GROUP];\n      weekday = util.WEEKDAY_OFFSET[weekday.toLowerCase()];\n      result.start.assign('weekday', weekday);\n    } // Text can be 'range' value. Such as '12 - 13 January 2012'\n\n\n    if (match[DATE_TO_GROUP]) {\n      var endDate = match[DATE_TO_NUM_GROUP] ? parseInt(match[DATE_TO_NUM_GROUP]) : util.ORDINAL_WORDS[match[DATE_TO_GROUP].trim().replace('-', ' ').toLowerCase()];\n      result.end = result.start.clone();\n      result.end.assign('day', endDate);\n    }\n\n    result.tags['ENMonthNameLittleEndianParser'] = true;\n    return result;\n  };\n};","map":null,"metadata":{},"sourceType":"script"}