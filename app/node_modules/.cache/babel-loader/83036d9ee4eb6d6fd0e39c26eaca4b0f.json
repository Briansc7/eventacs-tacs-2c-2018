{"ast":null,"code":"/*\n\n\n*/\nvar moment = require('moment');\n\nvar Parser = require('../parser').Parser;\n\nvar ParsedResult = require('../../result').ParsedResult;\n\nvar util = require('../../utils/EN');\n\nvar TIME_UNIT = '(' + util.INTEGER_WORDS_PATTERN + '|[0-9]+|an?(?:\\\\s*few)?|half(?:\\\\s*an?)?)\\\\s*' + '(sec(?:onds?)?|min(?:ute)?s?|hours?|weeks?|days?|months?|years?)\\\\s*';\nvar TIME_UNIT_STRICT = '([0-9]+|an?)\\\\s*' + '(seconds?|minutes?|hours?|days?)\\\\s*';\nvar PATTERN_TIME_UNIT = new RegExp(TIME_UNIT, 'i');\nvar PATTERN = new RegExp('' + '(\\\\W|^)' + '(?:within\\\\s*)?' + '((?:' + TIME_UNIT + ')+)' + '(?:ago|before|earlier)(?=(?:\\\\W|$))', 'i');\nvar STRICT_PATTERN = new RegExp('' + '(\\\\W|^)' + '(?:within\\\\s*)?' + '((?:' + TIME_UNIT_STRICT + ')+)' + 'ago(?=(?:\\\\W|$))', 'i');\n\nexports.Parser = function ENTimeAgoFormatParser() {\n  Parser.apply(this, arguments);\n\n  this.pattern = function () {\n    return this.isStrictMode() ? STRICT_PATTERN : PATTERN;\n  };\n\n  this.extract = function (text, ref, match, opt) {\n    if (match.index > 0 && text[match.index - 1].match(/\\w/)) return null;\n    var text = match[0];\n    text = match[0].substr(match[1].length, match[0].length - match[1].length);\n    index = match.index + match[1].length;\n    var result = new ParsedResult({\n      index: index,\n      text: text,\n      ref: ref\n    });\n    var fragments = extractDateTimeUnitFragments(match[2]);\n    var date = moment(ref);\n\n    for (var key in fragments) {\n      date.add(-fragments[key], key);\n    }\n\n    if (fragments['hour'] > 0 || fragments['minute'] > 0 || fragments['second'] > 0) {\n      result.start.assign('hour', date.hour());\n      result.start.assign('minute', date.minute());\n      result.start.assign('second', date.second());\n      result.tags['ENTimeAgoFormatParser'] = true;\n    }\n\n    if (fragments['d'] > 0 || fragments['month'] > 0 || fragments['year'] > 0) {\n      result.start.assign('day', date.date());\n      result.start.assign('month', date.month() + 1);\n      result.start.assign('year', date.year());\n    } else {\n      if (fragments['week'] > 0) {\n        result.start.imply('weekday', date.day());\n      }\n\n      result.start.imply('day', date.date());\n      result.start.imply('month', date.month() + 1);\n      result.start.imply('year', date.year());\n    }\n\n    return result;\n  };\n\n  function extractDateTimeUnitFragments(timeunitText) {\n    var fragments = {};\n    var remainingText = timeunitText;\n    var match = PATTERN_TIME_UNIT.exec(remainingText);\n\n    while (match) {\n      collectDateTimeFragment(match, fragments);\n      remainingText = remainingText.substring(match[0].length);\n      match = PATTERN_TIME_UNIT.exec(remainingText);\n    }\n\n    return fragments;\n  }\n\n  ;\n\n  function collectDateTimeFragment(match, fragments) {\n    var num = match[1].toLowerCase();\n\n    if (util.INTEGER_WORDS[num] !== undefined) {\n      num = util.INTEGER_WORDS[num];\n    } else if (num === 'a' || num === 'an') {\n      num = 1;\n    } else if (num.match(/few/)) {\n      num = 3;\n    } else if (num.match(/half/)) {\n      num = 0.5;\n    } else {\n      num = parseInt(num);\n    }\n\n    if (match[2].match(/hour/i)) {\n      fragments['hour'] = num;\n    } else if (match[2].match(/min/i)) {\n      fragments['minute'] = num;\n    } else if (match[2].match(/sec/i)) {\n      fragments['second'] = num;\n    } else if (match[2].match(/week/i)) {\n      fragments['week'] = num;\n    } else if (match[2].match(/day/i)) {\n      fragments['d'] = num;\n    } else if (match[2].match(/month/i)) {\n      fragments['month'] = num;\n    } else if (match[2].match(/year/i)) {\n      fragments['year'] = num;\n    }\n\n    return fragments;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}